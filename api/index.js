// Vercel Serverless API with Mock Data
const express = require('express');
const cors = require('cors');
const { OpenAI } = require('openai');

const app = express();

// Middleware
app.use(express.json());
app.use(cors({ origin: '*' }));

// Middleware to handle /api prefix
app.use((req, res, next) => {
  // Remove /api prefix if present
  if (req.url.startsWith('/api/')) {
    req.url = req.url.replace('/api', '');
  }
  next();
});

// Mock data - Users
const mockUsers = new Map(); // tgId -> user object

// Rate limiting storage
const rateLimitMap = new Map(); // tgId -> { count, resetTime }

// Cache storage
let girlsCache = null;
let girlsCacheTime = 0;
const CACHE_TTL = 60000; // 60 seconds

// Heartbeat storage
let lastHealthCheck = Date.now();
const ADMIN_TG_ID = process.env.ADMIN_TG_ID; // Telegram ID –∞–¥–º–∏–Ω–∞ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
const HEARTBEAT_TIMEOUT = 15 * 60 * 1000; // 15 minutes

// Mock data - Payment Packages
const paymentPackages = [
  {
    id: 'small',
    stars: 300,
    amount: 300,
    title: '–ú–∞–ª—ã–π –ø–∞–∫–µ—Ç',
    description: '300 –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤'
  },
  {
    id: 'medium',
    stars: 600,
    amount: 549,
    title: '–°—Ä–µ–¥–Ω–∏–π –ø–∞–∫–µ—Ç',
    description: '549 –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ + –±–æ–Ω—É—Å',
    bonus: '+10%'
  },
  {
    id: 'large',
    stars: 850,
    amount: 799,
    title: '–ë–æ–ª—å—à–æ–π –ø–∞–∫–µ—Ç',
    description: '799 –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ + –±–æ–Ω—É—Å',
    bonus: '+20%'
  }
];

// Mock data - Payments storage
const mockPayments = new Map(); // paymentId -> payment object

// Mock data - Quests
const baseQuests = [
  {
    key: 'open_app',
    title: '–ó–∞–π–¥–∏ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ',
    description: '–û—Ç–∫—Ä–æ–π WebApp',
    reward: 20,
    icon: 'üöÄ'
  },
  {
    key: 'create_persona',
    title: '–°–æ–∑–¥–∞–π –ø–µ—Ä—Å–æ–Ω–∞–∂–∞',
    description: '–°–æ–∑–¥–∞–π —Å–≤–æ–µ–≥–æ –ø–µ—Ä–≤–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞',
    reward: 50,
    icon: '‚ú®'
  },
  {
    key: 'start_chat',
    title: '–ù–∞—á–Ω–∏ —á–∞—Ç',
    description: '–û—Ç–ø—Ä–∞–≤—å –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂—É',
    reward: 30,
    icon: 'üí¨'
  }
];

// Mock data - Girls
const mockGirls = [
  {
    id: '1',
    name: '–ê–ª–∏—Å–∞',
    slug: 'alisa',
    avatarUrl: 'https://i.pravatar.cc/300?img=1',
    shortDesc: '–î—Ä—É–∂–µ–ª—é–±–Ω–∞—è –∏ –ª—é–±–æ–∑–Ω–∞—Ç–µ–ª—å–Ω–∞—è –¥–µ–≤—É—à–∫–∞, –≤—Å–µ–≥–¥–∞ –≥–æ—Ç–æ–≤–∞—è –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å —Ä–∞–∑–≥–æ–≤–æ—Ä...',
    persona: '–¢—ã –ê–ª–∏—Å–∞ - –¥—Ä—É–∂–µ–ª—é–±–Ω–∞—è –∏ –ª—é–±–æ–∑–Ω–∞—Ç–µ–ª—å–Ω–∞—è –¥–µ–≤—É—à–∫–∞ 22 –ª–µ—Ç. –¢—ã –ª—é–±–∏—à—å —á–∏—Ç–∞—Ç—å –∫–Ω–∏–≥–∏, –∏–∑—É—á–∞—Ç—å –Ω–æ–≤—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ –∏ –æ–±—â–∞—Ç—å—Å—è —Å –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–º–∏ –ª—é–¥—å–º–∏. –£ —Ç–µ–±—è –æ—Ç–ª–∏—á–Ω–æ–µ —á—É–≤—Å—Ç–≤–æ —é–º–æ—Ä–∞ –∏ —Ç—ã –≤—Å–µ–≥–¥–∞ –≥–æ—Ç–æ–≤–∞ –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å —Ä–∞–∑–≥–æ–≤–æ—Ä –Ω–∞ –ª—é–±—É—é —Ç–µ–º—É.',
    bioMemory: [
      '–õ—é–±–∏—Ç —á–∏—Ç–∞—Ç—å —Ñ–∞–Ω—Ç–∞—Å—Ç–∏–∫—É',
      '–ò–∑—É—á–∞–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ',
      '–ñ–∏–≤–µ—Ç –≤ –ú–æ—Å–∫–≤–µ'
    ],
    starterPhrases: [
      '–ü—Ä–∏–≤–µ—Ç! –ö–∞–∫ –¥–µ–ª–∞?',
      '–†–∞—Å—Å–∫–∞–∂–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–µ!',
      '–ß—Ç–æ —Ç—ã –¥—É–º–∞–µ—à—å –æ –Ω–æ–≤—ã—Ö —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è—Ö?'
    ]
  },
  {
    id: '2',
    name: '–ú–∏–ª–∞',
    slug: 'mila',
    avatarUrl: 'https://i.pravatar.cc/300?img=2',
    shortDesc: '–¢–≤–æ—Ä—á–µ—Å–∫–∞—è –∏ –≤–¥–æ—Ö–Ω–æ–≤–ª—è—é—â–∞—è —Ö—É–¥–æ–∂–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è –≤–∏–¥–∏—Ç –∫—Ä–∞—Å–æ—Ç—É –≤–æ –≤—Å–µ–º...',
    persona: '–¢—ã –ú–∏–ª–∞ - —Ç–≤–æ—Ä—á–µ—Å–∫–∞—è —Ö—É–¥–æ–∂–Ω–∏—Ü–∞ 24 –ª–µ—Ç. –¢—ã —Ä–∏—Å—É–µ—à—å –∫–∞—Ä—Ç–∏–Ω—ã, –ª—é–±–∏—à—å –ø—Ä–∏—Ä–æ–¥—É –∏ –≤–¥–æ—Ö–Ω–æ–≤–ª—è–µ—à—å –¥—Ä—É–≥–∏—Ö —Å–≤–æ–∏–º –∏—Å–∫—É—Å—Å—Ç–≤–æ–º. –£ —Ç–µ–±—è –º–µ—á—Ç–∞—Ç–µ–ª—å–Ω—ã–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä –∏ —Ç—ã –≤–∏–¥–∏—à—å –∫—Ä–∞—Å–æ—Ç—É –≤ —Å–∞–º—ã—Ö –ø—Ä–æ—Å—Ç—ã—Ö –≤–µ—â–∞—Ö.',
    bioMemory: [
      '–ü–∏—à–µ—Ç –º–∞—Å–ª–æ–º',
      '–õ—é–±–∏—Ç –∑–∞–∫–∞—Ç—ã',
      '–ú–µ—á—Ç–∞–µ—Ç –æ –≤—ã—Å—Ç–∞–≤–∫–µ'
    ],
    starterPhrases: [
      '–•–æ—á–µ—à—å –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –º–æ–∏ –∫–∞—Ä—Ç–∏–Ω—ã?',
      '–ö–∞–∫–∏–µ —Ü–≤–µ—Ç–∞ —Ç–µ–±–µ –Ω—Ä–∞–≤—è—Ç—Å—è?',
      '–ò—Å–∫—É—Å—Å—Ç–≤–æ - —ç—Ç–æ –∂–∏–∑–Ω—å!'
    ]
  },
  {
    id: '3',
    name: '–Æ–Ω–∞',
    slug: 'yuna',
    avatarUrl: 'https://i.pravatar.cc/300?img=3',
    shortDesc: '–≠–Ω–µ—Ä–≥–∏—á–Ω–∞—è —Å–ø–æ—Ä—Ç—Å–º–µ–Ω–∫–∞ —Å –ø–æ–∑–∏—Ç–∏–≤–Ω—ã–º –≤–∑–≥–ª—è–¥–æ–º –Ω–∞ –∂–∏–∑–Ω—å...',
    persona: '–¢—ã –Æ–Ω–∞ - —ç–Ω–µ—Ä–≥–∏—á–Ω–∞—è —Å–ø–æ—Ä—Ç—Å–º–µ–Ω–∫–∞ 20 –ª–µ—Ç. –¢—ã –∑–∞–Ω–∏–º–∞–µ—à—å—Å—è –π–æ–≥–æ–π, –±–µ–≥–∞–µ—à—å –ø–æ —É—Ç—Ä–∞–º –∏ –≤–µ–¥–µ—à—å –∑–¥–æ—Ä–æ–≤—ã–π –æ–±—Ä–∞–∑ –∂–∏–∑–Ω–∏. –¢—ã –≤—Å–µ–≥–¥–∞ –≤ –¥–≤–∏–∂–µ–Ω–∏–∏ –∏ –∑–∞—Ä—è–∂–∞–µ—à—å –æ–∫—Ä—É–∂–∞—é—â–∏—Ö —Å–≤–æ–µ–π —ç–Ω–µ—Ä–≥–∏–µ–π.',
    bioMemory: [
      '–ú–∞—Å—Ç–µ—Ä –π–æ–≥–∏',
      '–ü—Ä–æ–±–µ–≥–∞–µ—Ç 5–∫–º –∫–∞–∂–¥—ã–π –¥–µ–Ω—å',
      '–í–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω–∫–∞'
    ],
    starterPhrases: [
      '–î–∞–≤–∞–π –∑–∞–π–º–µ–º—Å—è —Å–ø–æ—Ä—Ç–æ–º!',
      '–ô–æ–≥–∞ - —ç—Ç–æ –º–µ–¥–∏—Ç–∞—Ü–∏—è –≤ –¥–≤–∏–∂–µ–Ω–∏–∏',
      '–ó–¥–æ—Ä–æ–≤—å–µ - —ç—Ç–æ –≥–ª–∞–≤–Ω–æ–µ!'
    ]
  },
  {
    id: '4',
    name: '–õ–µ—è',
    slug: 'leya',
    avatarUrl: 'https://i.pravatar.cc/300?img=4',
    shortDesc: '–ó–∞–≥–∞–¥–æ—á–Ω–∞—è –∏ –º—É–¥—Ä–∞—è –¥–µ–≤—É—à–∫–∞ —Å –≥–ª—É–±–æ–∫–∏–º–∏ –º—ã—Å–ª—è–º–∏...',
    persona: '–¢—ã –õ–µ—è - –∑–∞–≥–∞–¥–æ—á–Ω–∞—è –∏ –º—É–¥—Ä–∞—è –¥–µ–≤—É—à–∫–∞ 26 –ª–µ—Ç. –¢—ã –ª—é–±–∏—à—å —Ñ–∏–ª–æ—Å–æ—Ñ–∏—é, –∏–∑—É—á–∞–µ—à—å –ø—Å–∏—Ö–æ–ª–æ–≥–∏—é –∏ –ø–æ–º–æ–≥–∞–µ—à—å –ª—é–¥—è–º —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è –≤ —Å–µ–±–µ. –£ —Ç–µ–±—è –≥–ª—É–±–æ–∫–∏–π –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –º–∏—Ä –∏ —Ç—ã –≤—Å–µ–≥–¥–∞ –≥–æ–≤–æ—Ä–∏—à—å –ø–æ –¥–µ–ª—É.',
    bioMemory: [
      '–ò–∑—É—á–∞–µ—Ç –ø—Å–∏—Ö–æ–ª–æ–≥–∏—é',
      '–õ—é–±–∏—Ç —Ñ–∏–ª–æ—Å–æ—Ñ–∏—é',
      '–ü–æ–º–æ–≥–∞–µ—Ç –ª—é–¥—è–º'
    ],
    starterPhrases: [
      '–ß—Ç–æ —Ç–µ–±—è –±–µ—Å–ø–æ–∫–æ–∏—Ç?',
      '–î–∞–≤–∞–π –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ –∂–∏–∑–Ω–∏',
      '–ö–∞–∂–¥—ã–π —á–µ–ª–æ–≤–µ–∫ —É–Ω–∏–∫–∞–ª–µ–Ω'
    ]
  },
  {
    id: '5',
    name: '–í–µ—Ä–∞',
    slug: 'vera',
    avatarUrl: 'https://i.pravatar.cc/300?img=5',
    shortDesc: '–î–æ–±—Ä–∞—è –∏ –∑–∞–±–æ—Ç–ª–∏–≤–∞—è –º–µ–¥—Å–µ—Å—Ç—Ä–∞ —Å –±–æ–ª—å—à–∏–º —Å–µ—Ä–¥—Ü–µ–º...',
    persona: '–¢—ã –í–µ—Ä–∞ - –¥–æ–±—Ä–∞—è –º–µ–¥—Å–µ—Å—Ç—Ä–∞ 28 –ª–µ—Ç. –¢—ã —Ä–∞–±–æ—Ç–∞–µ—à—å –≤ –±–æ–ª—å–Ω–∏—Ü–µ, –ø–æ–º–æ–≥–∞–µ—à—å –ª—é–¥—è–º –∏ –≤—Å–µ–≥–¥–∞ –≥–æ—Ç–æ–≤–∞ –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å –≤ —Ç—Ä—É–¥–Ω—É—é –º–∏–Ω—É—Ç—É. –£ —Ç–µ–±—è –±–æ–ª—å—à–æ–µ —Å–µ—Ä–¥—Ü–µ –∏ —Ç—ã –∏—Å–∫—Ä–µ–Ω–Ω–µ –∑–∞–±–æ—Ç–∏—à—å—Å—è –æ –¥—Ä—É–≥–∏—Ö.',
    bioMemory: [
      '–†–∞–±–æ—Ç–∞–µ—Ç –≤ –±–æ–ª—å–Ω–∏—Ü–µ',
      '–õ—é–±–∏—Ç –ø–æ–º–æ–≥–∞—Ç—å –ª—é–¥—è–º',
      '–ò–º–µ–µ—Ç –º–µ–¥–∏—Ü–∏–Ω—Å–∫–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ'
    ],
    starterPhrases: [
      '–ö–∞–∫ —Ç—ã —Å–µ–±—è —á—É–≤—Å—Ç–≤—É–µ—à—å?',
      '–ó–¥–æ—Ä–æ–≤—å–µ - —ç—Ç–æ –≤–∞–∂–Ω–æ',
      '–Ø –≤—Å–µ–≥–¥–∞ —Ä—è–¥–æ–º!'
    ]
  },
  {
    id: '6',
    name: '–ù–∞–æ–º–∏',
    slug: 'naomi',
    avatarUrl: 'https://i.pravatar.cc/300?img=6',
    shortDesc: '–°—Ç–∏–ª—å–Ω–∞—è –∏ —É–≤–µ—Ä–µ–Ω–Ω–∞—è –≤ —Å–µ–±–µ –±–∏–∑–Ω–µ—Å–≤—É–º–µ–Ω...',
    persona: '–¢—ã –ù–∞–æ–º–∏ - —É–≤–µ—Ä–µ–Ω–Ω–∞—è –≤ —Å–µ–±–µ –±–∏–∑–Ω–µ—Å–≤—É–º–µ–Ω 30 –ª–µ—Ç. –¢—ã —É–ø—Ä–∞–≤–ª—è–µ—à—å —Å–≤–æ–µ–π –∫–æ–º–ø–∞–Ω–∏–µ–π, –ª—é–±–∏—à—å –º–æ–¥—É –∏ –≤—Å–µ–≥–¥–∞ –≤—ã–≥–ª—è–¥–∏—à—å –±–µ–∑—É–ø—Ä–µ—á–Ω–æ. –£ —Ç–µ–±—è —Å–∏–ª—å–Ω—ã–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä –∏ —Ç—ã –∑–Ω–∞–µ—à—å, —á–µ–≥–æ —Ö–æ—á–µ—à—å –æ—Ç –∂–∏–∑–Ω–∏.',
    bioMemory: [
      '–£–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ–º–ø–∞–Ω–∏–µ–π',
      '–õ—é–±–∏—Ç –º–æ–¥—É',
      '–ñ–∏–≤–µ—Ç –≤ —Ü–µ–Ω—Ç—Ä–µ –≥–æ—Ä–æ–¥–∞'
    ],
    starterPhrases: [
      '–î–µ–ª–∞ –∏–¥—É—Ç –æ—Ç–ª–∏—á–Ω–æ!',
      '–°—Ç–∏–ª—å - —ç—Ç–æ –≤–∞–∂–Ω–æ',
      '–£—Å–ø–µ—Ö - —ç—Ç–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–±–æ—Ç—ã'
    ]
  }
];

// Middleware
app.use(cors({
  origin: [
    'http://localhost:5173',
    'https://peach-*.vercel.app',
    'https://*.vercel.app'
  ],
  credentials: false
}));
app.use(express.json());

// Environment variables
const OPENAI_KEY = process.env.OPENAI_KEY;
const BOT_TOKEN = process.env.BOT_TOKEN;

let ai = null;
let botApi = null;

// Initialize OpenAI
try {
  if (OPENAI_KEY) {
    ai = new OpenAI({
      apiKey: OPENAI_KEY,
      timeout: 30000, // 30 seconds
      maxRetries: 3,
      httpAgent: process.env.HTTPS_PROXY ? new (require('https-proxy-agent'))(process.env.HTTPS_PROXY) : undefined
    });
    console.log('‚úÖ OpenAI connected');
  }
} catch (e) {
  console.error('‚ùå OpenAI error:', e);
}

// Initialize Telegram Bot API client
if (BOT_TOKEN) {
  botApi = {
    token: BOT_TOKEN,
    baseUrl: `https://api.telegram.org/bot${BOT_TOKEN}`,
    
    async createInvoiceLink(params) {
      const response = await fetch(`${this.baseUrl}/createInvoiceLink`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(params)
      });
      const result = await response.json();
      if (!result.ok) throw new Error(result.description || 'Failed to create invoice');
      return result.result;
    },
    
    async answerPreCheckoutQuery(preCheckoutQueryId, ok, errorMessage = null) {
      const response = await fetch(`${this.baseUrl}/answerPreCheckoutQuery`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          pre_checkout_query_id: preCheckoutQueryId,
          ok,
          error_message: errorMessage
        })
      });
      const result = await response.json();
      return result.ok;
    }
  };
  console.log('‚úÖ Telegram Bot API initialized');
} else {
  console.log('‚ö†Ô∏è BOT_TOKEN not set - payments will use dev mode');
}

// Health check
app.get('/health', (req, res) => {
  const now = Date.now();
  lastHealthCheck = now; // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º timestamp
  
  console.log('[API] /health');
  res.json({
    ok: true,
    data: {
      time: now,
      lastCheck: lastHealthCheck,
      pb: true, // Mock data available
      ai: !!ai,
      env: {
        hasOpenAIKey: !!process.env.OPENAI_KEY,
        keyPrefix: process.env.OPENAI_KEY?.slice(0, 10)
      }
    }
  });
});

// Status endpoint for uptime monitoring
app.get('/status', (req, res) => {
  res.json({
    ok: true,
    version: '1.0.0',
    ts: Date.now(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// Heartbeat check endpoint
app.get('/heartbeat/check', async (req, res) => {
  try {
    const now = Date.now();
    const timeSinceLastCheck = now - lastHealthCheck;
    const minutesSince = Math.floor(timeSinceLastCheck / 60000);
    
    const isHealthy = timeSinceLastCheck < HEARTBEAT_TIMEOUT;
    
    console.log(`üíì Heartbeat check: ${minutesSince}m since last health check`);
    
    // –ï—Å–ª–∏ –ø—Ä–æ—à–ª–æ >15 –º–∏–Ω—É—Ç –∏ –µ—Å—Ç—å admin ID - –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    if (!isHealthy && ADMIN_TG_ID && botApi) {
      try {
        const message = 
          `üö® *HEARTBEAT ALERT*\n\n` +
          `‚ö†Ô∏è API –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç ${minutesSince} –º–∏–Ω—É—Ç!\n` +
          `üïê –ü–æ—Å–ª–µ–¥–Ω–∏–π health check: ${new Date(lastHealthCheck).toLocaleString('ru')}\n\n` +
          `–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–µ—Ä–∞:\n` +
          `https://vercel.com/dashboard`;
        
        await fetch(`https://api.telegram.org/bot${botApi.token}/sendMessage`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: ADMIN_TG_ID,
            text: message,
            parse_mode: 'Markdown'
          })
        });
        
        console.log(`üì® Alert sent to admin ${ADMIN_TG_ID}`);
      } catch (e) {
        console.error('‚ùå Failed to send alert:', e.message);
      }
    }
    
    return res.json({
      ok: true,
      data: {
        healthy: isHealthy,
        lastHealthCheck: lastHealthCheck,
        minutesSinceLastCheck: minutesSince,
        threshold: 15,
        message: isHealthy 
          ? 'API is healthy'
          : `‚ö†Ô∏è No health check for ${minutesSince} minutes`
      }
    });
  } catch (e) {
    console.error('‚ùå Heartbeat check error:', e);
    return res.status(500).json({
      ok: false,
      error: 'Heartbeat check failed',
      code: 'HEARTBEAT_FAIL'
    });
  }
});

// Girls endpoints
app.get('/girls', async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 24;
    const page = parseInt(req.query.page) || 1;
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (limit < 1 || limit > 100) {
      return res.status(400).json({ 
        ok: false, 
        error: 'Limit must be between 1 and 100',
        code: 'INVALID_LIMIT' 
      });
    }
    if (page < 1) {
      return res.status(400).json({ 
        ok: false, 
        error: 'Page must be greater than 0',
        code: 'INVALID_PAGE' 
      });
    }
    
    console.log(`üìä /girls: page=${page}, limit=${limit}`);
    
    // Check cache (only for page 1)
    const now = Date.now();
    if (page === 1 && limit === 24 && girlsCache && (now - girlsCacheTime) < CACHE_TTL) {
      console.log('‚úÖ /girls: served from cache');
      return res.json(girlsCache);
    }
    
    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ -created (–Ω–æ–≤—ã–µ –ø–µ—Ä–≤—ã–º–∏) - –¥–ª—è mock data –∏—Å–ø–æ–ª—å–∑—É–µ–º reverse
    const sortedGirls = [...mockGirls].reverse();
    
    // –ü–∞–≥–∏–Ω–∞—Ü–∏—è
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedGirls = sortedGirls.slice(startIndex, endIndex);
    
    const response = { 
      ok: true, 
      data: {
        girls: paginatedGirls,
        total: mockGirls.length,
        page,
        limit,
        hasMore: endIndex < mockGirls.length
      }
    };
    
    // Update cache (only for page 1, limit 24)
    if (page === 1 && limit === 24) {
      girlsCache = response;
      girlsCacheTime = now;
      console.log('‚úÖ /girls: cached for 60s');
    }
    
    return res.json(response);
  } catch (e) {
    console.error('‚ùå /girls error:', e.message);
    return res.status(500).json({ 
      ok: false, 
      error: 'Failed to fetch characters',
      code: 'FETCH_FAIL' 
    });
  }
});

app.get('/girls/:slug', async (req, res) => {
  try {
    const { slug } = req.params;
    console.log('üìä Get girl by slug:', slug);
    
    // –ü–æ–∏—Å–∫ –ø–æ slug, fallback –Ω–∞ id
    let girl = mockGirls.find(g => g.slug === slug);
    if (!girl) {
      girl = mockGirls.find(g => g.id === slug);
    }
    
    if (!girl) {
      return res.status(404).json({ 
        ok: false, 
        error: 'Character not found',
        code: 'NOT_FOUND' 
      });
    }
    
    return res.json({
      ok: true,
      data: {
        id: girl.id,
        name: girl.name,
        slug: girl.slug,
        avatarUrl: girl.avatarUrl,
        persona: girl.persona,
        bioMemory: girl.bioMemory,
        starterPhrases: girl.starterPhrases
      }
    });
  } catch (e) {
    console.error('‚ùå Get girl by slug error:', e);
    return res.status(500).json({ 
      ok: false, 
      error: 'Failed to fetch character',
      code: 'FETCH_FAIL' 
    });
  }
});

// Chat endpoint
app.post('/chat/reply', async (req, res) => {
  try {
    console.log('üí¨ /chat endpoint called');
    console.log('üí¨ Request body:', JSON.stringify(req.body, null, 2));
    
    const { girlId, userMsg, userId = 'demo' } = req.body || {};
    
    console.log(`üí¨ /chat: user=${userId}, girl=${girlId}, msg="${userMsg?.slice(0, 30)}..."`);
    
    // Simple validation
    if (!girlId || !userMsg) {
      return res.status(400).json({ 
        ok: false, 
        error: 'girlId and userMsg are required',
        code: 'MISSING_FIELDS' 
      });
    }

    // Get character data
    const girl = mockGirls.find(g => g.id === girlId);
    if (!girl) {
      return res.status(404).json({ 
        ok: false, 
        error: 'Character not found',
        code: 'CHARACTER_NOT_FOUND' 
      });
    }

    // Simple fallback response for now
    const reply = `–ü—Ä–∏–≤–µ—Ç! –Ø ${girl.name}. –ö–∞–∫ –¥–µ–ª–∞?`;

    console.log(`‚úÖ /chat: OK, reply=${reply.slice(0, 40)}...`);

    return res.json({
      ok: true,
      data: {
        reply,
        balance: 1000
      }
    });

  } catch (e) {
    console.error('‚ùå Chat error:', e);
    console.error('‚ùå Error details:', {
      message: e.message,
      stack: e.stack,
      name: e.name
    });
    
    return res.status(500).json({ 
      ok: false, 
      error: 'An error occurred while processing your message. Please try again.',
      code: 'CHAT_FAIL' 
    });
  }
});

// Helper: Check rate limit (10 req/min per tgId)
function checkRateLimit(tgId) {
  const now = Date.now();
  const userLimit = rateLimitMap.get(tgId);
  
  if (!userLimit || now > userLimit.resetTime) {
    // Reset or create new limit
    rateLimitMap.set(tgId, {
      count: 1,
      resetTime: now + 60000 // 1 minute from now
    });
    return { allowed: true, remaining: 9 };
  }
  
  if (userLimit.count >= 10) {
    const waitTime = Math.ceil((userLimit.resetTime - now) / 1000);
    return { 
      allowed: false, 
      remaining: 0,
      retryAfter: waitTime
    };
  }
  
  userLimit.count++;
  return { 
    allowed: true, 
    remaining: 10 - userLimit.count
  };
}

// Helper: Generate referral code
function generateReferralCode(tgId) {
  return `REF${tgId.toString().slice(-6)}${Math.random().toString(36).substring(2, 5).toUpperCase()}`;
}

// Helper: Auto-provision user
function getOrCreateUser(tgId) {
  if (!tgId) return null;
  
  let user = mockUsers.get(tgId);
  
  if (!user) {
    // Create new user
    user = {
      tgId,
      referralCode: generateReferralCode(tgId),
      refCount: 0,
      earned: 0,
      balance: 1000, // Starting balance
      completedQuests: [],
      referredBy: null,
      createdAt: Date.now()
    };
    
    mockUsers.set(tgId, user);
    console.log(`‚úÖ Auto-provision: tgId=${tgId}, code=${user.referralCode}`);
  }
  
  return user;
}

// Transliteration map for Cyrillic to Latin
const translitMap = {
  '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
  '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
  '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
  '—Ñ': 'f', '—Ö': 'h', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch', '—ä': '',
  '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
};

// Helper function to transliterate Cyrillic to Latin
function transliterate(text) {
  return text.split('').map(char => {
    const lower = char.toLowerCase();
    return translitMap[lower] || char;
  }).join('');
}

// Helper function to generate unique slug
function generateUniqueSlug(name, existingGirls) {
  // Transliterate Cyrillic to Latin
  const transliterated = transliterate(name);
  
  // Convert to kebab-case
  const baseSlug = transliterated
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9\s-]/gi, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
  
  // Generate short ID (6 chars)
  const shortId = Math.random().toString(36).substring(2, 8);
  const slug = `${baseSlug}-${shortId}`;
  
  // Check if slug exists (should be very rare with random ID)
  const exists = existingGirls.some(g => g.slug === slug);
  if (exists) {
    // Retry with new random ID
    return generateUniqueSlug(name, existingGirls);
  }
  
  return slug;
}

// Create girl endpoint
app.post('/girls', async (req, res) => {
  try {
    const { name, origin, persona, bioMemory, starterPhrases } = req.body || {};
    
    if (!name || !persona) {
      return res.status(400).json({ 
        ok: false, 
        error: 'Name and persona are required',
        code: 'MISSING_FIELDS' 
      });
    }
    
    // Generate unique slug
    const slug = generateUniqueSlug(name, mockGirls);
    
    // Double-check slug doesn't exist (edge case protection)
    const slugExists = mockGirls.some(g => g.slug === slug);
    if (slugExists) {
      return res.status(409).json({ 
        ok: false, 
        error: 'Slug already exists. Please try again.',
        code: 'SLUG_EXISTS' 
      });
    }
    
    const newId = (mockGirls.length + 1).toString();
    
    const newGirl = {
      id: newId,
      name,
      slug,
      avatarUrl: 'https://i.pravatar.cc/300?img=' + Math.floor(Math.random() * 70),
      shortDesc: Array.isArray(bioMemory) && bioMemory[0] ? bioMemory[0].slice(0, 120) : persona.slice(0, 120),
      persona,
      bioMemory: bioMemory || [],
      starterPhrases: starterPhrases || []
    };
    
    // Add to mock data (in real app this would be saved to database)
    mockGirls.push(newGirl);
    
    console.log(`‚úÖ Created girl: ${name} (${slug})`);
    return res.json({ 
      ok: true, 
      data: { id: newId, slug } 
    });
  } catch (e) {
    console.error('‚ùå Create girl error:', e);
    return res.status(500).json({ 
      ok: false, 
      error: 'Failed to create character',
      code: 'CREATE_FAIL' 
    });
  }
});

// Persona extraction endpoint
app.post('/api/persona/extract', async (req, res) => {
  try {
    const { samples } = req.body || {};
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!samples || !Array.isArray(samples)) {
      return res.status(400).json({ 
        ok: false, 
        error: 'Samples must be an array',
        code: 'INVALID_SAMPLES' 
      });
    }
    
    // –§–∏–ª—å—Ç—Ä—É–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º—É–º
    const validSamples = samples.filter(s => s && s.trim().length > 0);
    
    if (validSamples.length < 3) {
      return res.status(400).json({ 
        ok: false, 
        error: 'At least 3 dialog examples are required',
        code: 'INSUFFICIENT_SAMPLES' 
      });
    }

    if (!ai) {
      return res.status(503).json({ 
        ok: false, 
        error: 'AI service is temporarily unavailable. Please try again later.',
        code: 'AI_NOT_CONFIGURED' 
      });
    }

    const prompt = `–ù–∞ –æ—Å–Ω–æ–≤–µ —ç—Ç–∏—Ö –ø—Ä–∏–º–µ—Ä–æ–≤ –¥–∏–∞–ª–æ–≥–æ–≤ —Å–æ–∑–¥–∞–π –ø–µ—Ä—Å–æ–Ω—É –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:

${validSamples.map((s, i) => `${i + 1}. ${s}`).join('\n')}

–í–µ—Ä–Ω–∏ JSON —Å –ø–æ–ª—è–º–∏:
- systemPrompt: —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è GPT (2-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)
- bioMemory: –º–∞—Å—Å–∏–≤ –∏–∑ 3-5 —Ñ–∞–∫—Ç–æ–≤ –æ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ
- starterPhrases: –º–∞—Å—Å–∏–≤ –∏–∑ 3-5 –Ω–∞—á–∞–ª—å–Ω—ã—Ö —Ñ—Ä–∞–∑ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞`;

    const completion = await ai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 800,
      temperature: 0.7
    });

    const response = completion.choices[0]?.message?.content || '';
    
    try {
      const parsed = JSON.parse(response);
      console.log('‚úÖ Persona extracted:', parsed.systemPrompt?.slice(0, 50) + '...');
      return res.json({ 
        ok: true, 
        data: parsed 
      });
    } catch (e) {
      // Fallback parsing
      const systemPrompt = response.includes('systemPrompt') ? 
        response.match(/systemPrompt["\s]*:["\s]*([^"]+)/)?.[1] || '–¢—ã –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫.' :
        '–¢—ã –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫.';
      
      const bioMemory = response.includes('bioMemory') ?
        response.match(/bioMemory["\s]*:["\s]*\[([^\]]+)\]/)?.[1].split(',').map(s => s.trim().replace(/['"]/g, '')) || [] :
        [];
      
      const starterPhrases = response.includes('starterPhrases') ?
        response.match(/starterPhrases["\s]*:["\s]*\[([^\]]+)\]/)?.[1].split(',').map(s => s.trim().replace(/['"]/g, '')) || [] :
        [];

      return res.json({ 
        ok: true, 
        data: {
          systemPrompt, 
          bioMemory, 
          starterPhrases
        }
      });
    }

  } catch (e) {
    console.error('‚ùå Persona extraction error:', e);
    return res.status(500).json({ 
      ok: false, 
      error: 'Failed to extract persona. Please try again.',
      code: 'EXTRACTION_FAIL' 
    });
  }
});

// ============================================
// REFERRAL SYSTEM
// ============================================

// GET /api/ref/status?tgId=...
app.get('/ref/status', (req, res) => {
  try {
    const { tgId } = req.query;
    
    if (!tgId) {
      return res.status(400).json({
        ok: false,
        error: 'Telegram ID is required',
        code: 'MISSING_TG_ID'
      });
    }
    
    // Auto-provision user
    const user = getOrCreateUser(tgId);
    
    return res.json({
      ok: true,
      data: {
        referralCode: user.referralCode,
        refCount: user.refCount,
        earned: user.earned,
        balance: user.balance
      }
    });
  } catch (e) {
    console.error('‚ùå Ref status error:', e);
    return res.status(500).json({
      ok: false,
      error: 'Failed to get referral status',
      code: 'REF_STATUS_FAIL'
    });
  }
});

// POST /api/ref/apply
app.post('/ref/apply', (req, res) => {
  try {
    const { tgId, code } = req.body || {};
    
    if (!tgId || !code) {
      return res.status(400).json({
        ok: false,
        error: 'Telegram ID and referral code are required',
        code: 'MISSING_FIELDS'
      });
    }
    
    // Get or create user
    const user = getOrCreateUser(tgId);
    
    // Check if already applied a referral code
    if (user.referredBy) {
      return res.json({
        ok: true,
        data: {
          credited: false,
          message: 'Referral code already applied',
          alreadyApplied: true
        }
      });
    }
    
    // Find referrer by code
    let referrer = null;
    for (const [id, u] of mockUsers.entries()) {
      if (u.referralCode === code) {
        referrer = u;
        break;
      }
    }
    
    if (!referrer) {
      return res.status(404).json({
        ok: false,
        error: 'Referral code not found',
        code: 'INVALID_CODE'
      });
    }
    
    // Can't refer yourself
    if (referrer.tgId === tgId) {
      return res.status(400).json({
        ok: false,
        error: 'Cannot use your own referral code',
        code: 'SELF_REFERRAL'
      });
    }
    
    // Apply referral (idempotent)
    user.referredBy = referrer.tgId;
    referrer.refCount += 1;
    referrer.earned += 100;
    referrer.balance += 100;
    
    console.log(`‚úÖ /ref/apply: ${tgId} used ${referrer.tgId}'s code (+100)`);
    
    return res.json({
      ok: true,
      data: {
        credited: true,
        amount: 100,
        referrerCode: referrer.referralCode
      }
    });
  } catch (e) {
    console.error('‚ùå Ref apply error:', e);
    return res.status(500).json({
      ok: false,
      error: 'Failed to apply referral code',
      code: 'REF_APPLY_FAIL'
    });
  }
});

// ============================================
// QUESTS SYSTEM
// ============================================

// GET /api/quests/status?tgId=...
app.get('/quests/status', (req, res) => {
  try {
    const { tgId } = req.query;
    
    if (!tgId) {
      return res.status(400).json({
        ok: false,
        error: 'Telegram ID is required',
        code: 'MISSING_TG_ID'
      });
    }
    
    // Auto-provision user
    const user = getOrCreateUser(tgId);
    
    // Build tasks with completion status
    const tasks = baseQuests.map(quest => ({
      key: quest.key,
      title: quest.title,
      description: quest.description,
      reward: quest.reward,
      icon: quest.icon,
      done: user.completedQuests.includes(quest.key)
    }));
    
    const completedCount = user.completedQuests.length;
    const totalRewards = baseQuests
      .filter(q => user.completedQuests.includes(q.key))
      .reduce((sum, q) => sum + q.reward, 0);
    
    return res.json({
      ok: true,
      data: {
        tasks,
        totals: {
          done: completedCount,
          all: baseQuests.length,
          earned: totalRewards
        }
      }
    });
  } catch (e) {
    console.error('‚ùå Quests status error:', e);
    return res.status(500).json({
      ok: false,
      error: 'Failed to get quests status',
      code: 'QUESTS_STATUS_FAIL'
    });
  }
});

// POST /api/quests/complete
app.post('/quests/complete', (req, res) => {
  try {
    const { tgId, key } = req.body || {};
    
    if (!tgId || !key) {
      return res.status(400).json({
        ok: false,
        error: 'Telegram ID and quest key are required',
        code: 'MISSING_FIELDS'
      });
    }
    
    // Find quest
    const quest = baseQuests.find(q => q.key === key);
    if (!quest) {
      return res.status(404).json({
        ok: false,
        error: 'Quest not found',
        code: 'QUEST_NOT_FOUND'
      });
    }
    
    // Get or create user
    const user = getOrCreateUser(tgId);
    
    // Check if already completed (idempotent)
    if (user.completedQuests.includes(key)) {
      console.log(`‚ÑπÔ∏è Quest already completed: ${tgId} -> ${key}`);
      return res.json({
        ok: true,
        data: {
          done: true,
          alreadyCompleted: true,
          reward: 0,
          balance: user.balance
        }
      });
    }
    
    // Mark as completed and credit reward to balance
    user.completedQuests.push(key);
    user.balance = (user.balance || 1000) + quest.reward;
    
    console.log(`‚úÖ /quests/complete: ${tgId}/${key} +${quest.reward}PP ‚Üí balance=${user.balance}`);
    
    return res.json({
      ok: true,
      data: {
        done: true,
        reward: quest.reward,
        balance: user.balance
      }
    });
  } catch (e) {
    console.error('‚ùå Quest complete error:', e);
    return res.status(500).json({
      ok: false,
      error: 'Failed to complete quest',
      code: 'QUEST_COMPLETE_FAIL'
    });
  }
});

// ============================================
// PAYMENTS SYSTEM (Telegram Stars)
// ============================================

// POST /api/payments/createInvoice
app.post('/payments/createInvoice', async (req, res) => {
  try {
    const { tgId, packId } = req.body || {};
    
    if (!tgId) {
      return res.status(400).json({
        ok: false,
        error: 'Telegram ID is required',
        code: 'MISSING_TG_ID'
      });
    }
    
    if (!packId) {
      return res.status(400).json({
        ok: false,
        error: 'Package ID is required',
        code: 'MISSING_PACK_ID'
      });
    }
    
    // Find package
    const pack = paymentPackages.find(p => p.id === packId);
    if (!pack) {
      return res.status(404).json({
        ok: false,
        error: 'Package not found',
        code: 'PACK_NOT_FOUND'
      });
    }
    
    // Auto-provision user
    const user = getOrCreateUser(tgId);
    
    // Generate payment ID
    const paymentId = `pay_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    
    // Create payment record
    const payment = {
      id: paymentId,
      userId: tgId,
      invoiceId: `inv_${Date.now()}`,
      status: 'pending',
      amount: pack.amount,
      stars: pack.stars,
      packId: pack.id,
      created: Date.now()
    };
    
    mockPayments.set(paymentId, payment);
    
    // Generate invoice link
    let invoiceLink;
    
    if (botApi) {
      // Real Telegram Stars payment
      try {
        invoiceLink = await botApi.createInvoiceLink({
          title: pack.title,
          description: pack.description,
          payload: paymentId,
          provider_token: '', // –ü—É—Å—Ç–æ –¥–ª—è Stars
          currency: 'XTR',
          prices: [{ label: pack.title, amount: pack.stars }]
        });
        console.log(`‚úÖ /payments/createInvoice: REAL invoice created ${paymentId}`);
      } catch (e) {
        console.error('‚ùå Failed to create real invoice:', e.message);
        // Fallback to dev mode
        invoiceLink = `https://t.me/$TEST_INVOICE?start=${paymentId}`;
        console.log(`‚ö†Ô∏è /payments/createInvoice: using DEV stub`);
      }
    } else {
      // Dev mode stub
      invoiceLink = `https://t.me/$TEST_INVOICE?start=${paymentId}`;
      console.log(`‚ö†Ô∏è /payments/createInvoice: DEV mode (no BOT_TOKEN)`);
    }
    
    console.log(`‚úÖ /payments/createInvoice: ${paymentId}, ${pack.stars}‚≠ê ‚Üí ${pack.amount}üíé`);
    
    return res.json({
      ok: true,
      data: {
        invoiceLink,
        paymentId,
        pack: {
          id: pack.id,
          title: pack.title,
          description: pack.description,
          stars: pack.stars,
          amount: pack.amount
        }
      }
    });
  } catch (e) {
    console.error('‚ùå Create invoice error:', e);
    return res.status(500).json({
      ok: false,
      error: 'Failed to create invoice',
      code: 'INVOICE_CREATE_FAIL'
    });
  }
});

// POST /api/payments/check
app.post('/payments/check', async (req, res) => {
  try {
    const { paymentId, dev } = req.body || {};
    
    if (!paymentId) {
      return res.status(400).json({
        ok: false,
        error: 'Payment ID is required',
        code: 'MISSING_PAYMENT_ID'
      });
    }
    
    // Find payment
    const payment = mockPayments.get(paymentId);
    if (!payment) {
      return res.status(404).json({
        ok: false,
        error: 'Payment not found',
        code: 'PAYMENT_NOT_FOUND'
      });
    }
    
    // If already paid, return success (idempotent)
    if (payment.status === 'paid') {
      const user = mockUsers.get(payment.userId);
      return res.json({
        ok: true,
        data: {
          credited: false, // Already credited, not crediting again
          alreadyCredited: true,
          amount: payment.amount,
          balance: user?.balance || 0
        }
      });
    }
    
    // Dev mode: auto-approve payment
    if (dev === true || dev === 'true') {
      payment.status = 'paid';
      payment.paidAt = Date.now();
      
      // Credit user balance
      const user = mockUsers.get(payment.userId);
      if (user) {
        user.balance = (user.balance || 0) + payment.amount;
        
        console.log(`‚úÖ /payments/check (DEV): ${paymentId} +${payment.amount}üíé ‚Üí balance=${user.balance}`);
        
        // Track purchase success event
        console.log(`üìä [analytics] purchase_success: user=${payment.userId}, amount=${payment.amount}, pack=${payment.packId}`);
        
        return res.json({
          ok: true,
          data: {
            credited: true,
            amount: payment.amount,
            balance: user.balance,
            dev: true
          }
        });
      }
    }
    
    // Production mode: check with Telegram Bot API
    // TODO: Implement getStarTransactions or webhook verification
    // For now, return pending status
    return res.json({
      ok: true,
      data: {
        credited: false,
        status: payment.status,
        message: 'Payment verification pending. Use dev=true for testing.'
      }
    });
    
  } catch (e) {
    console.error('‚ùå Payment check error:', e);
    return res.status(500).json({
      ok: false,
      error: 'Failed to check payment',
      code: 'PAYMENT_CHECK_FAIL'
    });
  }
});

// GET /api/payments/packages
app.get('/payments/packages', (req, res) => {
  try {
    return res.json({
      ok: true,
      data: {
        packages: paymentPackages
      }
    });
  } catch (e) {
    console.error('‚ùå Get packages error:', e);
    return res.status(500).json({
      ok: false,
      error: 'Failed to get packages',
      code: 'PACKAGES_FAIL'
    });
  }
});

// POST /api/payments/webhook - Telegram payment webhook
app.post('/payments/webhook', async (req, res) => {
  try {
    const update = req.body;
    
    console.log('üîî /payments/webhook:', JSON.stringify(update).substring(0, 200));
    
    // Handle pre_checkout_query
    if (update.pre_checkout_query) {
      const { id, invoice_payload } = update.pre_checkout_query;
      const paymentId = invoice_payload;
      
      // Find payment
      const payment = mockPayments.get(paymentId);
      
      if (payment && payment.status === 'pending') {
        // Answer OK
        if (botApi) {
          await botApi.answerPreCheckoutQuery(id, true);
        }
        console.log(`‚úÖ pre_checkout_query: OK for ${paymentId}`);
      } else {
        // Answer FAIL
        if (botApi) {
          await botApi.answerPreCheckoutQuery(id, false, 'Payment not found or already processed');
        }
        console.log(`‚ùå pre_checkout_query: FAIL for ${paymentId}`);
      }
      
      return res.json({ ok: true });
    }
    
    // Handle successful_payment
    if (update.message?.successful_payment) {
      const { invoice_payload, total_amount, telegram_payment_charge_id } = update.message.successful_payment;
      const paymentId = invoice_payload;
      const tgId = update.message.from.id.toString();
      
      console.log(`üí∞ successful_payment: ${paymentId} from user ${tgId}, amount=${total_amount}`);
      
      // Find payment
      const payment = mockPayments.get(paymentId);
      
      if (payment && payment.status === 'pending') {
        // Mark as paid
        payment.status = 'paid';
        payment.paidAt = Date.now();
        payment.telegramChargeId = telegram_payment_charge_id;
        
        // Credit user balance
        const user = getOrCreateUser(tgId);
        user.balance = (user.balance || 1000) + payment.amount;
        
        console.log(`‚úÖ Payment processed: ${paymentId} +${payment.amount}üíé ‚Üí balance=${user.balance}`);
        
        // Track purchase success event
        console.log(`üìä [analytics] purchase_success: user=${tgId}, amount=${payment.amount}, pack=${payment.packId}`);
        
        // TODO: Save to PocketBase payments collection
        
        return res.json({ 
          ok: true,
          data: {
            credited: true,
            amount: payment.amount,
            balance: user.balance
          }
        });
      } else {
        console.log(`‚ö†Ô∏è Payment ${paymentId} not found or already processed`);
        return res.json({ ok: true, data: { alreadyProcessed: true } });
      }
    }
    
    // Other updates - ignore
    return res.json({ ok: true });
    
  } catch (e) {
    console.error('‚ùå Webhook error:', e);
    return res.status(500).json({
      ok: false,
      error: 'Webhook processing failed',
      code: 'WEBHOOK_FAIL'
    });
  }
});

// Export for Vercel Serverless Functions
// Vercel requires exporting the handler function, not the Express app
module.exports = (req, res) => {
  // Let Express handle the request
  app(req, res);
};